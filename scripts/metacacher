#!/usr/bin/env ruby

DEBUG = ENV['DEBUG'] || ''
VERSION = '0.0.1'

# Path to `hash_files`.
# Can be changed by setting $HASH_FILES_BIN.
HASH_FILES_BIN = ENV['HASH_FILES_BIN'] || 'scripts/hash_files'

def debug(*args)
  return if (ENV['DEBUG'] || '').empty?
  STDERR.printf("\e[2mdebug:\e[1m %s\e[m\n", args.map(&:to_s).join(' '))
end

def err(*args)
  STDERR.printf("\e[1;31mError:\e[m %s\n", args.map(&:to_s).join(' '))
end

def random_string(bytes = 12)
  require 'securerandom'
  SecureRandom.base64(bytes)
end

# Make sure to echo random strings so as to always invalidate the cache.
def die(*args)
  # Echo some random strings for cache key
  puts "error-#{random_string}"
  if args.length > 0
    err(*args)
  end
  exit 1
end

# By default, the fingerprint does not depend on hash_files nor the script 
# itself, so as to keep the hash stable.
# But it can be configured (by $HASH_META) to depend on them.
@dependencies = []

META_HASH = ENV['HASH_META'] || ''
if META_HASH != 'false' &&
  ! META_HASH.empty?

  @dependencies << HASH_FILES_BIN
  @dependencies << $0
end

# If we are running in a GitHub workflow, add the workflow file as a 
# dependency.
if ENV['GITHUB_WORKFLOW_REF'].kind_of? String

  # Extract relative path for the workflow file
  @dependencies << ENV['GITHUB_WORKFLOW_REF']
    .sub(%r{^.*(\.github/workflows)}, '\1')
    .sub(%r{@refs/.*$}, '')
end

RUBY_DEPENDENCIES = %w(
  .tool-versions
  Gemfile
  Gemfile.lock
)

METANORMA_DEPENDENCIES = [] + RUBY_DEPENDENCIES

JEKYLL_DEPENDENCIES = RUBY_DEPENDENCIES + %w(
  favicon.ico
  favicon.png
  robots.txt
  _includes
  _input
  _layouts
  _pages
  _sass
  assets
  fonts
  iev
  js
  pubdocs
  relaton
)

def parse_command(args)
  case args[0]
  when 'jekyll' then
      args.shift

      jekyll_yaml = args[0] || ENV['JEKYLL_YAML'] || 'config.yml'
      if ! File.readable?(jekyll_yaml)
        die "#{jekyll_yaml} not found or not readable."
      end

      @dependencies << jekyll_yaml
      @dependencies += JEKYLL_DEPENDENCIES

      hash_files @dependencies

  when 'metanorma' then
      args.shift

      metanorma_yaml = args[0] || ENV['METANORMA_YAML'] || 'metanorma.yml'
      if ! File.readable?(metanorma_yaml)
        die "#{metanorma_yaml} not found or not readable."
      end

      @dependencies << metanorma_yaml
      @dependencies += METANORMA_DEPENDENCIES

      require 'yaml'
      @dependencies += YAML.load_file(metanorma_yaml).dig('metanorma', 'source', 'files')

      hash_files @dependencies

  when 'version' then
      puts "#{$0} v#{VERSION}"
      exit
  else
      print_usage
      die
      # ???
  end
end


def hash_files(args)
  require 'open3'
  stdout_str, stderr_str, status = Open3.capture3(HASH_FILES_BIN, *args)

  # Re-echo stdout and stderr
  STDERR.puts stderr_str
  puts stdout_str
end

def print_usage
  STDERR.puts <<EOF
Usage: #{$0} jekyll    PATH/TO/CONFIG.YML
       #{$0} metanorma PATH/TO/METANORMA.YML
       #{$0} version

EOF
end


# Reads metanorma.yml to get a list of file dependencies.
def main(args)
  parse_command(args)
end

main ARGV
