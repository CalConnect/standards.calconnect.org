#!/usr/bin/env bash

# For files generated by `metanorma site generate` to the `_site/` directory,
# move and rename them so they follow a precise and concise path structure,
# so that the deployed website also follows such a structure.
#
# E.g.,
# Move from:
#   _site/specification/documents/src-documents/cc-admin-documents/cc-0701-miniop-usecases-tasks/document.*
# to:
#   _site/cc/cc-s0701-2007.*

shopt -s extglob

VERSION="0.0.1"

log() {
  printf "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: %b\n" "$*"
} >&2

err() {
  printf "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: \e[1;31mError:\e[m %b\n" "$*"
} >&2

_debug() {
  printf "[$(date +'%Y-%m-%dT%H:%M:%S%z')]: \e[1;33mDebug:\e[m %b\n" "$*"
} >&2

debug() {
  if [[ -n "${DEBUG}" ]]
  then
    _debug "$@"
  fi
} >&2

ecdo() {
  log "Running: $*"
  "$@"
}

DOC_TYPE="${DOC_TYPE:-}"
DOC_CLASS="${DOC_CLASS:-}"
SITE_DIR="${SITE_DIR:-_site}"
SITE_SUB_DIR="${SITE_SUB_DIR:-}"
PUBLIC_PATH="${PUBLIC_PATH:-cc}"
EXCLUDE="${EXCLUDE:-empty*}"
MV_COMMAND="${MV_COMMAND:-cp}"

# House keeping
FILES_TO_MOVE=()
FILES_MOVED=()
FILES_TO_UPDATE=()
FILES_UPDATED=()
NO_DOCID=()
FILES_EXCLUDED=()

print_summary() {
  if [[ "${COMMAND:-}" = flags ]]
  then
    return
  fi

  log "Moved ${#FILES_MOVED[@]} out of ${#FILES_TO_MOVE[@]} files"
  log "Updated references in ${#FILES_UPDATED[@]} out of ${#FILES_TO_UPDATE[@]} files"

  if [[ "${#FILES_EXCLUDED[@]}" -gt 0 ]]
  then
    log "Excluded ${#FILES_EXCLUDED[@]} files:"
    for file in "${FILES_EXCLUDED[@]}"
    do
      log "${file}"
    done
  fi

  if [[ "${#FILES_MOVE_FAILURE[@]}" -gt 0 ]]
  then
    err "Failed to get document ID for ${#FILES_MOVE_FAILURE[@]} files:"
    for failure in "${FILES_MOVE_FAILURE[@]}"
    do
      err "${failure}"
    done
  fi

  if [[ "${#FILES_UPDATE_FAILURE[@]}" -gt 0 ]]
  then
    err "Failed to get document ID for ${#FILES_UPDATE_FAILURE[@]} files:"
    for failure in "${FILES_UPDATE_FAILURE[@]}"
    do
      err "${failure}"
    done
  fi

  if [[ "${#NO_DOCID[@]}" -gt 0 ]]
  then
    err "Failed to get document ID for ${#NO_DOCID[@]} files:"
    for failure in "${NO_DOCID[@]}"
    do
      err "${failure}"
    done
  fi
}

trap print_summary EXIT

show_usage() {
  local prog_name="\e[1m${0}\e[22m"

  printf "%b" "Usage: $prog_name
       $prog_name [-h|--help]
       $prog_name --version

    For files generated by \`metanorma site generate\` to the \`_site/\` directory,
    move and rename them so they follow a precise and concise path structure,
    so that the deployed website also follows such a structure.

    E.g.,
    Move from:
      _site/specification/documents/src-documents/cc-admin-documents/cc-0701-miniop-usecases-tasks/document.*
    to:
      _site/cc/cc-s0701-2007.*

\e[4mMandatory environment variables\e[24m:
  SITE_SUB_DIR    The sub-directory under SITE_DIR where the non-canonicalized
                  files are located

\e[4mOptional environment variables\e[24m:
  SITE_DIR        The directory where Jekyll artifacts are generated, where the
                  canonicalized files will be moved to
                  (default: _site)

  PUBLIC_PATH     A directory of the same name will be created under SITE_DIR
                  to contain all canonicalized files
                  (default: cc)

  EXCLUDE         A glob pattern for files to exclude from processing
                  (default: empty*)

"

}

# Read Relaton XML file (.rxl) for an individual document (relaton split it if
# in a collection?) and split out the document ID in lowercase
#
rxl2id() {
  local rxl_file="${1:?Missing Relaton XML file}"
  BUNDLE_GEMFILE=src-documents/Gemfile \
    bundle exec relaton convert "${rxl_file}" -f yaml \
    2>/dev/null && \
    yq -r '.id | ascii_downcase' "${rxl_file%.rxl}.yaml"
}

# Move a file and replace its occurrences with the new destination
# in all files found in SITE_DIR
move-file() {
  local src="${1:?Missing source file path}"
  local dest="${2:?Missing dest file name}"

  debug move-file "$src" "$dest"

  # For each ${SITE_SUB_DIR} subdirectory,
  # replace-paths
  #
  local replace_from="${src#"${SITE_DIR}/"}"
  local replace_to="${dest#"${SITE_DIR}/"}"
  local site_sub_dir_src="${replace_from#"${SITE_SUB_DIR%/}/"}"
  local site_sub_dir_dest="${SITE_SUB_DIR//+([^\/])/..}/${replace_to}"

  FILES_TO_MOVE+=("$src")
  # mv "$src" "$dest" && \
  ${MV_COMMAND:-cp} "$src" "$dest" && \
    replace-paths "${site_sub_dir_src}" "${site_sub_dir_dest}" && \
    replace-paths "${replace_from}" "${replace_to}" && \
    FILES_MOVED+=("$src") || \
    FILES_MOVE_FAILURE+=("$src")
}

# Replace all occurrences of $src with $dest
# in all files found in SITE_DIR.
#
# NOTE: These paths are assumed to be under SITE_DIR,
# so make sure they do not already begin with "$SITE_DIR/".
#
# NOTE: time complexity: O(n^2) where n = number of documents
#
replace-paths() {
  local src="${1:?Missing source file path}"
  local dest="${2:?Missing dest file name}"

  debug replace-paths "$src" "$dest"

  local tmp_file

  while read -r file
  do
    FILES_TO_UPDATE+=("$file")
    # Use temp file to allow for Linux/macOS sed differences of `-i`
    tmp_file="${file}.tmp"
    # debug sed "s@${src}@${dest}@g"
    < "$file" sed "s@${src}@${dest}@g" > "${tmp_file}" && \
      mv "${tmp_file}" "$file" && \
      FILES_UPDATED+=("$file") || \
      FILES_UPDATE_FAILURE+=("$file")
  done < <(find "$SITE_DIR" -type f -name "*.html")
}


doit() {
  local rxl_src_dir="${1:?Missing source directory for RXL files}"
  local rxl_file_basename
  local file_basename
  local src
  local dest
  local format
  local file
  local file_name_no_ext
  local docid
  local src_dir
  local dest_dir
  local formats

  dest_dir="${SITE_DIR}${PUBLIC_PATH:+"/${PUBLIC_PATH}"}"

  log "Making sure ${dest_dir} exists."
  mkdir -p "${dest_dir}"

  while read -r rxl_file
  do

    # Exclude ignored files
    if [[ -n "${EXCLUDE}" && "${rxl_file}" == *${EXCLUDE} ]]
    then
      debug "Ignoring ${rxl_file}"
      FILES_EXCLUDED+=("${rxl_file}")
      continue
    fi

    # Reset
    formats=()

    # Read src dir to discover other formats
    src_dir="${rxl_file%/*}"

    rxl_file_basename="${rxl_file##*/}"
    rxl_file_basename="${rxl_file_basename%%.*}"
    while read -r file
    do
      debug "Got file in '$src_dir': '${file}'"
      file_basename="${file##*/}"
      formats+=("${file_basename#"${rxl_file_basename}".}")
    done < <(find "$src_dir" -type f -name "${rxl_file_basename}.*")

    docid=$(rxl2id "${rxl_file}")
    if [[ -z "${docid}" ]]
    then
      err "Failed to get document ID for ${rxl_file}"
      err "Run this to reproduce:"
      err "  BUNDLE_GEMFILE=src-documents/Gemfile \
  bundle exec relaton convert \"${rxl_file}\" -f yaml \
  2>/dev/null \
  && yq -r '.id | ascii_downcase' \"${rxl_file%.rxl}.yaml\""
      NO_DOCID+=("${rxl_file}")
      continue
    fi

    for format in "${formats[@]}"
    do
      file_name_no_ext="${rxl_file%.*}"
      src="${file_name_no_ext}.${format}"
      dest="${dest_dir}/${docid}.${format}"
      move-file "$src" "$dest"
    done
  done < <(find "${rxl_src_dir}" -type f -name "*.rxl")
}

main() {

  debug "EXCLUDE is ${EXCLUDE}"
  debug "SITE_DIR is ${SITE_DIR}"
  debug "PUBLIC_PATH is ${PUBLIC_PATH}"
  debug "SITE_SUB_DIR is ${SITE_SUB_DIR}"
  debug "MV_COMMAND is ${MV_COMMAND}"

  if [[ "$1" == "-h" || "$1" == "--help" ]]
  then
    show_usage
    exit 0
  elif [[ "$1" == "--version" ]]
  then
    echo "${0} v${VERSION}"
    exit 0
  fi

  if [[ -z "${SITE_DIR:-}" ]]
  then
    err "SITE_DIR is not set"
    exit 1
  else
    # Sanitize SITE_DIR
    SITE_DIR="${SITE_DIR%/}"
  fi

  if [[ -z "${SITE_SUB_DIR:-}" ]]
  then
    err "SITE_SUB_DIR is not set"
    exit 1
  elif [[ ! -d "${SITE_DIR}/${SITE_SUB_DIR}" ]]
  then
    err "Directory ${SITE_DIR}/${SITE_SUB_DIR} does not exist"
    exit 1
  else
    # Sanitize SITE_SUB_DIR
    SITE_SUB_DIR="${SITE_SUB_DIR%/}"
  fi

  doit "${SITE_DIR}/${SITE_SUB_DIR}"
}

main "$@"
