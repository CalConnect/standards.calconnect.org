#!/usr/bin/env ruby
# frozen_string_literal: true

# For files generated by `metanorma site generate` to the `_site/` directory,
# move and rename them so they follow a precise and concise path structure,
# so that the deployed website also follows such a structure.
#
# E.g.,
# Move from:
#   _site/specification/documents/src-documents/cc-admin-documents/cc-0701-miniop-usecases-tasks/document.*
# to:
#   _site/cc/cc-s0701-2007.*

DEBUG = ENV['DEBUG'] || ''
VERSION = '0.0.1'

require 'relaton/cli'
require 'nokogiri'

def date
  Time.now.strftime('%Y-%m-%dT%H:%M:%S%z')
end

def err(*args)
  $stderr.printf("[#{date}] \e[1;31mError:\e[m %s\n", args.map(&:to_s).join(' '))
end

def log(*args)
  $stderr.printf("[#{date}] %s\n", args.map(&:to_s).join(' '))
end

def _debug(*args)
  $stderr.printf("[#{date}] \e[2mdebug:\e[1m %s\e[m\n", args.map(&:to_s).join(' '))
end

def debug(*args)
  return if (ENV['DEBUG'] || '').empty?

  _debug(*args)
end

DOC_TYPE = ENV['DOC_TYPE'] || ''
DOC_CLASS = ENV['DOC_CLASS'] || ''
@SITE_DIR = ENV['SITE_DIR'] || '_site'
@SITE_SUB_DIR = ENV['SITE_SUB_DIR'] || ''
PUBLIC_PATH = ENV['PUBLIC_PATH'] || 'cc'
RXL_EXCLUDE = ENV['RXL_EXCLUDE'] || 'empty*'
EXCLUDE = ENV['EXCLUDE'] || '.{err,presentation}.*'
MV = ENV['MV'] || ''

# House keeping
PATH_REPLACEMENTS = {}
FILES_TO_MOVE = []
FILES_MOVED = []
FILES_TO_UPDATE = []
FILES_UPDATED = []
NO_DOCID = []
FILES_EXCLUDED = []
FILES_UPDATE_FAILURE = []
FILES_MOVE_FAILURE = []

@printed_summary = false

def print_summary(*_args)
  return if @printed_summary

  @printed_summary = true

  log "Moved #{FILES_MOVED.length} out of #{FILES_TO_MOVE.length} files"
  log "Updated references in #{FILES_UPDATED.length} out of #{FILES_TO_UPDATE.length} files"

  PATH_REPLACEMENTS.each do |src, dest|
    log "replace_paths: #{src} => #{dest}"
  end

  FILES_UPDATED.each do |file|
    log file
  end

  unless FILES_EXCLUDED.empty?
    log "Excluded #{FILES_EXCLUDED.length} files:"
    FILES_EXCLUDED.each do |file|
      log file
    end
  end

  unless FILES_MOVE_FAILURE.empty?
    err "Failed to move #{FILES_MOVE_FAILURE.length} files:"
    FILES_MOVE_FAILURE.each do |failure|
      err failure
    end
  end

  unless FILES_UPDATE_FAILURE.empty?
    err "Failed to update path references in #{FILES_UPDATE_FAILURE.length} files:"
    FILES_UPDATE_FAILURE.each do |failure|
      err failure
    end
  end

  return if NO_DOCID.empty?

  err "Failed to get document ID for #{NO_DOCID.length} files:"
  NO_DOCID.each do |failure|
    err failure
  end
end

at_exit do
  print_summary
end

Signal.trap('INT', lambda do
  print_summary
  exit 1
end)

def show_usage(*_args)
  prog_name = "\e[1m#{$PROGRAM_NAME}\e[22m"

  warn <<~USAGE
    Usage: #{prog_name}
         #{prog_name} [-h|--help]
         #{prog_name} --version

      For files generated by \`metanorma site generate\` to the \`_site/\` directory,
      move and rename them so they follow a precise and concise path structure,
      so that the deployed website also follows such a structure.

      E.g.,
      Move from:
        _site/specification/documents/src-documents/cc-admin-documents/cc-0701-miniop-usecases-tasks/document.*
      to:
        _site/cc/cc-s0701-2007.*

    \e[4mMandatory environment variables\e[24m:
      SITE_SUB_DIR    The sub-directory under SITE_DIR where the non-canonicalized
                      files are located

    \e[4mOptional environment variables\e[24m:
      SITE_DIR        The directory where Jekyll artifacts are generated, where the
                      canonicalized files will be moved to
                      (default: _site)

      PUBLIC_PATH     A directory of the same name will be created under SITE_DIR
                      to contain all canonicalized files
                      (default: cc)

      RXL_EXCLUDE     A glob pattern for RXL files to exclude from processing
                      (default: empty*)

  USAGE
end

# List all files within a directory, recursively
def find(dir, glob = '*')
  glob_arg = "#{dir}/**/#{glob}"
  debug "find: #{dir}, #{glob} => #{glob_arg}, #{Dir.glob(glob_arg).length} files"
  Dir.glob(glob_arg).select { |f| File.file?(f) }
end

def xml_from_file(file)
  Nokogiri::XML(File.read(file, encoding: 'utf-8'))
end

# Read Relaton XML file (.rxl) for an individual document (relaton split it if
# in a collection?) and split out the document ID in lowercase
#
def rxl2id(rxl_file)
  raise 'Missing Relaton XML file' if rxl_file.nil? || rxl_file.empty?

  bibdata = Relaton::Bibdata.from_xml(xml_from_file(rxl_file))
  bibdata.id.downcase
end

# Move a file and replace its occurrences with the new destination
# in all files found in SITE_DIR
def move_file(src, dest, site_dir:, site_sub_dir:)
  raise 'Missing source file path' if src.nil? || src.empty?
  raise 'Missing dest file name' if dest.nil? || dest.empty?

  debug "move_file: #{src} => #{dest}"

  site_dir_no_leading_slash = site_dir.sub(%r{^/*}, '')
  site_sub_dir_no_trailing_slash = site_sub_dir.sub(%r{/*$}, '')

  # For each ${SITE_SUB_DIR} subdirectory,
  # replace_paths
  #
  replace_from = src.sub(%r{^(/)*#{site_dir_no_leading_slash}}, '\1')
  replace_to = dest.sub(%r{^(/)*#{site_dir_no_leading_slash}}, '\1')

  site_sub_dir_src = replace_from.sub(%r{^(/)*#{site_sub_dir_no_trailing_slash}/}, '')

  # Move 'replace_to' up 'n' levels, where 'n' is the number of slash segments in
  # 'site_sub_dir_src':
  #   'a/b/c' => '../../..'
  site_sub_dir_dest = Pathname.new(site_sub_dir.gsub(%r{[^/]+}, '..'))
                              .join(replace_to.sub(%r{^/*}, ''))
                              .to_s

  # debug "site_dir = #{site_dir.inspect}\n" \
  #       "site_sub_dir = #{site_sub_dir.inspect}\n" \
  #       "replace_from = #{replace_from.inspect}\n" \
  #       "replace_to = #{replace_to.inspect}\n" \
  #       "site_sub_dir_src = replace_from.sub(/^\#{site_sub_dir.sub(%r{/*$}, '')}/, '')\n" \
  #       "site_sub_dir_dest = Pathname.new(site_sub_dir.gsub(%r{[^/]+}, '..')).join(replace_to).to_s"
  # exit

  FILES_TO_MOVE << src

  begin
    if ENV['MV'].nil? || ENV['MV'].empty?
      FileUtils.cp(src, dest)
    else
      FileUtils.mv(src, dest)
    end
    queue_replace_paths(replace_from, replace_to)
    queue_replace_paths(site_sub_dir_src, site_sub_dir_dest)
  rescue StandardError => e
    err "Failed to move #{src} to #{dest}: #{e}"
    FILES_MOVE_FAILURE << src
    throw e
  end

  FILES_MOVED << src
end

require 'tempfile'

# Replace all occurrences of pattern with replacement in file
def sed_i(file, pattern_replacements)
  buffer = File.read(file)
  new_buffer = pattern_replacements.inject(buffer) do |l, (pattern, replacement)|
    l.gsub(pattern, replacement)
  end

  ## Verify buffer matches pattern
  matches = pattern_replacements.each_with_object([]) do |(pattern, _replacement), acc|
    acc << pattern if buffer.include?(pattern)
  end

  debug "sed_i: #{file} => #{matches.empty? ? 'No' : "(#{matches.length}) has"} replacements"
  if matches.empty?
    debug 'No matches.  Continuing.'
    return
  end

  # Verify new_buffer has no patterns
  unless matches.empty?
    new_matches = pattern_replacements.each_with_object([]) do |(pattern, _replacement), acc|
      acc << pattern if new_buffer.include?(pattern)
    end

    unless new_matches.empty?
      error "New buffer still has patterns: #{new_matches}"
      exit 1
    end
  end

  if buffer == new_buffer && !matches.empty?
    err "No replacements made in #{file}"
    exit 1
  end

  Tempfile.create do |tempfile|
    tempfile.puts(new_buffer)
    # tempfile.close
    FileUtils.mv(tempfile.path, file)
  end

  debug "Updated #{file}"
  FILES_UPDATED << file
end

# Populate PATH_REPLACEMENTS for #replace_paths to do all replacements
# at the end.
#
# NOTE: These paths are assumed to be under @SITE_DIR,
# so make sure they do not already begin with @SITE_DIR/.
#
# NOTE: time complexity: O(n^2) where n = number of documents
#
def queue_replace_paths(src, dest)
  raise 'Missing source file path' if src.nil? || src.empty?
  raise 'Missing dest file name' if dest.nil? || dest.empty?

  debug "queue_replace_paths: #{src} => #{dest}"
  PATH_REPLACEMENTS[src] = dest
end

# Replace all occurrences of $src with $dest
# in all files found in @SITE_DIR.
#
def replace_paths
  debug "replace_paths starting: #{PATH_REPLACEMENTS.length} replacements"

  files_to_replace = find(@SITE_DIR, '*.{ht,x}ml')
  debug "files_to_replace: #{files_to_replace.length} files"

  files_to_replace.each do |file|
    if File.fnmatch?("*#{EXCLUDE}", file, File::FNM_EXTGLOB)
      debug "Ignoring #{file}"
      next
    end

    FILES_TO_UPDATE << file
    begin
      sed_i(file, PATH_REPLACEMENTS)
    rescue StandardError => e
      err "Failed to update #{file}: #{e}"
      FILES_UPDATE_FAILURE << file
      throw e
    end
  end

  debug "replace_paths done: #{FILES_UPDATED.length} files updated"
end

def doit(rxl_src_dir, site_dir:, site_sub_dir:)
  raise 'Missing source directory for RXL files' if rxl_src_dir.nil? || rxl_src_dir.empty?

  dest_dir = site_dir
  dest_dir = "#{dest_dir}/#{PUBLIC_PATH}" if !PUBLIC_PATH.nil? && !PUBLIC_PATH.empty?

  log "Making sure #{dest_dir} exists."

  FileUtils.mkdir_p(dest_dir)

  find(rxl_src_dir, '*.rxl').each do |rxl_file|
    debug "Got file in '#{rxl_src_dir}': '#{rxl_file}'"

    # Exclude ignored files
    if !RXL_EXCLUDE.nil? && !RXL_EXCLUDE.empty? && File.fnmatch?("*#{RXL_EXCLUDE}", rxl_file, File::FNM_EXTGLOB)
      debug "Ignoring #{rxl_file}"
      FILES_EXCLUDED << rxl_file
      next
    end
    debug "Not ignoring #{rxl_file}: File.fnmatch?('*#{RXL_EXCLUDE}', #{rxl_file.inspect}, File::FNM_EXTGLOB)"

    # Reset
    formats = []

    # Read src dir to discover other formats
    src_dir = File.dirname(rxl_file)

    rxl_file_basename = File.basename(rxl_file)
    rxl_file_basename = rxl_file_basename.gsub(%r{(\.[^/]*)+$}, '')

    debug "rxl_file_basename = #{rxl_file_basename.inspect}"

    find(src_dir, "#{rxl_file_basename}.*").each do |file|
      if File.fnmatch?("*#{EXCLUDE}", file, File::FNM_EXTGLOB)
        debug "Ignoring #{file}"
        next
      end
      debug "Got file in '#{src_dir}': '#{file}'"
      file_basename = File.basename(file)
      formats << file_basename.sub(/^#{rxl_file_basename}\./, '')
    end

    docid = rxl2id(rxl_file)
    if docid.nil? || docid.empty?
      err "Failed to get document ID for #{rxl_file}"
      NO_DOCID << rxl_file
      next
    end

    formats.each do |format|
      file_name_no_ext = rxl_file.sub(%r{(\.[^/]*)+$}, '')
      src = "#{file_name_no_ext}.#{format}"
      dest = Pathname.new(dest_dir).join("#{docid}.#{format}").to_s
      move_file(src, dest, site_dir: site_dir, site_sub_dir: site_sub_dir)
    end
  end

  replace_paths
end

def main(*args)
  debug "EXCLUDE is #{EXCLUDE}"
  debug "RXL_EXCLUDE is #{RXL_EXCLUDE}"
  debug "@SITE_DIR is #{@SITE_DIR}"
  debug "PUBLIC_PATH is #{PUBLIC_PATH}"
  debug "@SITE_SUB_DIR is #{@SITE_SUB_DIR}"
  debug "MV is #{MV}"

  case args[0]
  when '--version'
    puts "#{$PROGRAM_NAME} v#{VERSION}"
    exit 0
  when '--help', '-h'
    show_usage
    exit 0
  end

  if @SITE_DIR.nil? || @SITE_DIR.empty?
    err '@SITE_DIR is not set'
    exit 1
  else
    # Sanitize @SITE_DIR
    @SITE_DIR = @SITE_DIR.sub(%r{/*$}, '')
  end

  if @SITE_SUB_DIR.nil? || @SITE_SUB_DIR.empty?
    err '@SITE_SUB_DIR is not set'
    exit 1
  elsif !File.directory?(Pathname(@SITE_DIR).join(@SITE_SUB_DIR))
    err "Directory #{Pathname(@SITE_DIR).join(@SITE_SUB_DIR)} does not exist"
    exit 1
  else
    # Sanitize @SITE_SUB_DIR
    @SITE_SUB_DIR = @SITE_SUB_DIR.sub(%r{/*$}, '')
  end

  doit(
    Pathname(@SITE_DIR).join(@SITE_SUB_DIR),
    site_dir: @SITE_DIR,
    site_sub_dir: @SITE_SUB_DIR
  )
end

main ARGV
